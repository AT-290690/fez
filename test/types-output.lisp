(let char:A Atom)
(let char:B Atom)
(let char:C Atom)
(let char:D Atom)
(let char:E Atom)
(let char:F Atom)
(let char:G Atom)
(let char:H Atom)
(let char:I Atom)
(let char:J Atom)
(let char:K Atom)
(let char:L Atom)
(let char:M Atom)
(let char:N Atom)
(let char:O Atom)
(let char:P Atom)
(let char:Q Atom)
(let char:R Atom)
(let char:S Atom)
(let char:T Atom)
(let char:U Atom)
(let char:V Atom)
(let char:W Atom)
(let char:X Atom)
(let char:Y Atom)
(let char:Z Atom)
(let char:a Atom)
(let char:b Atom)
(let char:c Atom)
(let char:d Atom)
(let char:e Atom)
(let char:f Atom)
(let char:g Atom)
(let char:h Atom)
(let char:i Atom)
(let char:j Atom)
(let char:k Atom)
(let char:l Atom)
(let char:m Atom)
(let char:n Atom)
(let char:o Atom)
(let char:p Atom)
(let char:q Atom)
(let char:r Atom)
(let char:s Atom)
(let char:t Atom)
(let char:u Atom)
(let char:v Atom)
(let char:w Atom)
(let char:x Atom)
(let char:y Atom)
(let char:z Atom)
(let char:0 Atom)
(let char:1 Atom)
(let char:2 Atom)
(let char:3 Atom)
(let char:4 Atom)
(let char:5 Atom)
(let char:6 Atom)
(let char:7 Atom)
(let char:8 Atom)
(let char:9 Atom)
(let char:empty Atom)
(let char:double-quote Atom)
(let char:new-line Atom)
(let char:space Atom)
(let char:comma Atom)
(let char:dot Atom)
(let char:semi-colon Atom)
(let char:colon Atom)
(let char:dash Atom)
(let char:left-brace Atom)
(let char:right-brace Atom)
(let char:curly-left-brace Atom)
(let char:curly-right-brace Atom)
(let char:left-bracket Atom)
(let char:right-bracket Atom)
(let char:pipe Atom)
(let char:hash Atom)
(let char:question-mark Atom)
(let char:exclamation-mark Atom)
(let char:minus Atom)
(let char:plus Atom)
(let char:equal Atom)
(let char:asterix Atom)
(let char:ampersand Atom)
(let char:at Atom)
(let char:backtick Atom)
(let char:digit? (lambda Atom (do Atom)))
(let identity (lambda Unknown (do Unknown)))
(let Scope Atom)
(let Special Atom)
(let Library Atom)
(let Type Atom)
(let Search Atom)
(let truthy? (lambda Unknown (do Atom)))
(let falsy? (lambda Unknown (do Atom)))
(let true? (lambda Unknown (do Atom)))
(let false? (lambda Unknown (do Atom)))
(let math:e Atom)
(let math:pi Atom)
(let math:min-safe-integer Atom)
(let math:max-safe-integer Atom)
(let math:decimal-scaling Atom)
(let tuple:apply (lambda Collection (lambda Any Any (do Unknown)) (do Unknown)))
(let tuple:add (lambda Collection (do Atom)))
(let tuple:subtract (lambda Collection (do Atom)))
(let tuple:multiply (lambda Collection (do Atom)))
(let tuple:divide (lambda Collection (do Atom)))
(let tuple:swap (lambda Collection (do Collection)))
(let temp Unknown)
(let tuple:swap! (lambda Collection (do Collection)))
(let tuple:zip (lambda Collection (do Unknown)))
(let tuple:list-zip (lambda Collection (do Collection)))
(let recursive:math:range (lambda Collection Atom (do Unknown)))
(let math:range (lambda Atom Atom (do Unknown)))
(let end Atom)
(let recursive:math:sequence (lambda Collection Atom (do Unknown)))
(let math:sequence (lambda Collection (do Unknown)))
(let recursive:sequence-n (lambda Collection Atom (do Unknown)))
(let math:sequence-n (lambda Atom (do Unknown)))
(let recursive:math:zeroes (lambda Collection (do Unknown)))
(let math:zeroes (lambda Atom (do Unknown)))
(let recursive:math:ones (lambda Collection (do Unknown)))
(let math:ones (lambda Atom (do Unknown)))
(let recursive:math:numbers (lambda Collection (do Unknown)))
(let math:numbers (lambda Atom Unknown (do Unknown)))
(let math:between? (lambda Atom Atom Atom (do Atom)))
(let math:overlap? (lambda Atom Atom Atom (do Atom)))
(let math:permutations (lambda Collection (do Collection)))
(let out Collection)
(let combinations (lambda Collection Atom Atom Collection (do Atom)))
(let math:combinations (lambda Collection (do Collection)))
(let math:greater? (lambda Atom Atom (do Atom)))
(let math:lesser? (lambda Atom Atom (do Atom)))
(let math:lesser-or-equal? (lambda Atom Atom (do Atom)))
(let math:greater-or-equal? (lambda Atom Atom (do Atom)))
(let math:equal? (lambda Atom Atom (do Atom)))
(let math:addition (lambda Atom Atom (do Atom)))
(let math:multiplication (lambda Atom Atom (do Atom)))
(let math:division (lambda Atom Atom (do Atom)))
(let math:subtraction (lambda Atom Atom (do Atom)))
(let math:summation (lambda Collection (do Atom)))
(let math:product (lambda Collection (do Atom)))
(let math:max (lambda Atom Atom (do Atom)))
(let math:min (lambda Atom Atom (do Atom)))
(let math:maximum (lambda Collection (do Atom)))
(let math:minimum (lambda Collection (do Atom)))
(let math:maximum-index (lambda Collection (do Any)))
(let math:minimum-index (lambda Collection (do Any)))
(let math:max-length (lambda Collection (do Collection)))
(let math:min-length (lambda Collection (do Collection)))
(let math:increment (lambda Atom (do Atom)))
(let math:decrement (lambda Atom (do Atom)))
(let math:floor (lambda Atom (do Atom)))
(let math:round (lambda Atom (do Atom)))
(let math:ceil (lambda Atom (do Atom)))
(let math:set-bit (lambda Atom Atom (do Atom)))
(let math:clear-bit (lambda Atom Atom (do Atom)))
(let math:power-of-two-bits (lambda Atom (do Atom)))
(let math:odd-bit? (lambda Atom (do Atom)))
(let math:average-bit (lambda Atom Atom (do Atom)))
(let math:flag-flip (lambda Atom (do Atom)))
(let math:toggle-bit (lambda Atom Atom Atom (do Atom)))
(let math:same-sign-bit? (lambda Atom Atom (do Atom)))
(let math:max-bit (lambda Atom Atom (do Atom)))
(let math:min-bit (lambda Atom Atom (do Atom)))
(let math:bit-equal? (lambda Atom Atom (do Atom)))
(let math:modulo-bit (lambda Atom Atom (do Atom)))
(let math:n-one-bit? (lambda Atom Atom (do Atom)))
(let len Atom)
(let half Atom)
(let math:median (lambda Collection (do Any)))
(let math:mean (lambda Collection (do Atom)))
(let n1 Atom)
(let n2 Atom)
(let math:bit-count32 (lambda Atom (do Atom)))
(let recursive:math:bit-count (lambda Atom Atom (do Atom)))
(let math:bit-count (lambda Atom (do Atom)))
(let math:square (lambda Atom (do Atom)))
(let math:power (lambda Atom Atom (do Any)))
(let recursive:math:greatest-common-divisor (lambda Atom Atom (do Atom)))
(let math:greatest-common-divisor (lambda Atom Atom (do Atom)))
(let math:least-common-divisor (lambda Atom Atom (do Atom)))
(let math:coprime? (lambda Atom Atom (do Atom)))
(let good-enough? (lambda Atom Atom (do Atom)))
(let improve-guess (lambda Atom Atom (do Atom)))
(let recursive:math:sqrt (lambda Atom Atom (do Unknown)))
(let math:sqrt (lambda Atom (do Unknown)))
(let math:perfect-square? (lambda Atom (do Atom)))
(let math:circumference (lambda Atom (do Atom)))
(let math:hypotenuse (lambda Atom Atom (do Unknown)))
(let math:abs (lambda Atom (do Atom)))
(let math:nth-digit (lambda Atom Atom (do Atom)))
(let math:remove-nth-digits (lambda Atom Atom (do Atom)))
(let recursive:math:keep-nth-digits (lambda Atom Atom Atom (do Unknown)))
(let math:keep-nth-digits (lambda Atom Atom (do Unknown)))
(let math:normalize (lambda Atom Atom Atom (do Atom)))
(let math:linear-interpolation (lambda Atom Atom Atom (do Atom)))
(let math:gauss-sum (lambda Atom (do Atom)))
(let math:gauss-sum-sequance (lambda Atom Atom (do Atom)))
(let math:clamp (lambda Atom Atom (do Atom)))
(let math:clamp-range (lambda Atom Atom Atom (do Any)))
(let math:odd? (lambda Atom (do Atom)))
(let math:even? (lambda Atom (do Atom)))
(let math:enumerated-odd? (lambda Unknown Atom (do Atom)))
(let math:enumerated-even? (lambda Unknown Atom (do Atom)))
(let math:sign (lambda Atom (do Atom)))
(let math:radians (lambda Atom (do Atom)))
(let math:average (lambda Atom Atom (do Atom)))
(let math:euclidean-mod (lambda Atom Atom (do Atom)))
(let a Atom)
(let b Atom)
(let math:euclidean-distance (lambda Atom Atom Atom Atom (do Unknown)))
(let math:manhattan-distance (lambda Atom Atom Atom Atom (do Atom)))
(let math:positive? (lambda Atom (do Atom)))
(let math:negative? (lambda Atom (do Atom)))
(let math:invert (lambda Atom (do Atom)))
(let math:zero? (lambda Atom (do Atom)))
(let math:negative-one? (lambda Atom (do Atom)))
(let math:divisible? (lambda Atom Atom (do Atom)))
(let math:factorial (lambda Atom (do Atom)))
(let sine Collection)
(let recursive:math:sine (lambda Atom (do Any)))
(let math:sine (lambda Atom Atom (do Any)))
(let cosine Collection)
(let recursive:math:cosine (lambda Atom (do Any)))
(let math:cosine (lambda Atom Atom (do Any)))
(let a Collection)
(let n Collection)
(let f Collection)
(let recursive:math:prime-factors (lambda  (do Atom)))
(let math:prime-factors (lambda Unknown (do Collection)))
(let prime? Atom)
(let recursive:math:prime (lambda Atom Atom (do Unknown)))
(let math:prime? (lambda Atom (do Atom)))
(let math:number-of-digits (lambda Atom (do Atom)))
(let N1 Atom)
(let N2 Atom)
(let N3 Atom)
(let N4 Atom)
(let math:largest-power (lambda Atom (do Atom)))
(let math:cartesian-product (lambda Collection Collection (do Collection)))
(let memoized:math:fibonacci (lambda Atom (do Atom)))
(let math:fibonacci (lambda Atom (do Atom)))
(let I Collection)
(let i Atom)
(let enumeration (lambda  (do Unknown)))
(let math:enumeration (lambda  (do Unknown)))
(let math:palindrome? (lambda Collection (do Atom)))
(let math:max-sub-array-sum (lambda Collection (do Any)))
(let math:list-maximum (lambda Collection (do Atom)))
(let math:list-minimum (lambda Unknown (do Atom)))
(let math:list-summation (lambda Unknown (do Atom)))
(let math:list-product (lambda Unknown (do Atom)))
(let math:list-range (lambda Atom Atom (do Collection)))
(let list:pair (lambda Unknown Unknown (do Collection)))
(let list:car (lambda Collection (do Any)))
(let list:cdr (lambda Collection (do Any)))
(let list:head (lambda Collection (do Any)))
(let list:tail (lambda Collection (do Any)))
(let list:nil? (lambda Collection (do Atom)))
(let list:map (lambda Collection (lambda Any (do Unknown)) (do Collection)))
(let list:filter (lambda Collection (lambda Any (do Unknown)) (do Collection)))
(let list:fold (lambda Collection (lambda Unknown Any (do Unknown)) Unknown (do Atom)))
(let list:zip (lambda Unknown Unknown (do Collection)))
(let list:unzip (lambda Collection (do Collection)))
(let list:length (lambda Collection (do Atom)))
(let list:enumerate (lambda Collection (do Collection)))
(let list:reverse (lambda Collection (do Atom)))
(let list:find (lambda Collection (lambda Any (do Unknown)) (do Collection)))
(let list:find-tail (lambda Collection (lambda Any (do Unknown)) (do Collection)))
(let list:some? (lambda Collection (lambda Any (do Unknown)) (do Atom)))
(let list:every? (lambda Collection (lambda Any (do Atom)) (do Atom)))
(let remove (lambda Collection Atom (do Any)))
(let list:remove-at (lambda Collection Atom (do Any)))
(let list:insert-at (lambda Collection Atom Unknown (do Collection)))
(let l Collection)
(let list:get (lambda Collection Atom (do Any)))
(let list:end (lambda Collection (do Any)))
(let fst Any)
(let xss Any)
(let list:rotate-left (lambda Collection (do Collection)))
(let lst Any)
(let xss Any)
(let list:rotate-right (lambda Collection (do Collection)))
(let list:concat! (lambda Collection (do Atom)))
(let list:merge! (lambda Collection Unknown (do Unknown)))
(let list:flatten (lambda Collection (do Collection)))
(let list:equal? (lambda Collection Collection (do Atom)))
(let list:count-of (lambda Collection (lambda Unknown (do Unknown)) (do Atom)))
(let list:count (lambda Collection Atom (do Atom)))
(let list:take (lambda Collection Atom (do Collection)))
(let list:after (lambda Collection Atom (do Any)))
(let list:slice (lambda Collection Atom Atom (do Collection)))
(let list:for (lambda Collection (lambda Any (do Unknown)) (do Collection)))
(let array:first (lambda Collection (do Any)))
(let array:second (lambda Collection (do Any)))
(let array:third (lambda Collection (do Any)))
(let array:last (lambda Collection (do Any)))
(let recursive:array:for (lambda Atom (do Atom)))
(let array:for (lambda Collection (lambda Any (do Unknown)) (do Collection)))
(let out Collection)
(let array:buckets (lambda Atom (do Collection)))
(let array:enumerated-for (lambda Collection (lambda Any Atom (do Unknown)) (do Collection)))
(let recursive:array:fill (lambda Collection Atom (do Unknown)))
(let array:fill (lambda Atom (lambda  (do Unknown)) (do Unknown)))
(let recursive:array:of (lambda Collection Atom (do Unknown)))
(let array:of (lambda Atom (lambda Atom (do Unknown)) (do Unknown)))
(let recursive:array:map (lambda Atom Collection (do Unknown)))
(let array:map (lambda Collection (lambda Any (do Unknown)) (do Collection)))
(let recursive:array:select (lambda Atom Collection (do Unknown)))
(let array:select (lambda Collection (lambda Any (do Unknown)) (do Collection)))
(let recursive:array:exclude (lambda Atom Collection (do Unknown)))
(let array:exclude (lambda Collection (lambda Any (do Atom)) (do Unknown)))
(let recursive:array:fold (lambda Atom Unknown (do Unknown)))
(let array:fold (lambda Collection (lambda Unknown Any (do Unknown)) Unknown (do Collection)))
(let recursive:array:every? (lambda Atom (do Atom)))
(let array:every? (lambda Collection (lambda Any (do Atom)) (do Atom)))
(let recursive:array:some? (lambda Atom (do Atom)))
(let array:some? (lambda Collection (lambda Any (do Atom)) (do Atom)))
(let array:find (lambda Collection Unknown (do Any)))
(let index Atom)
(let array:find-option (lambda Collection Unknown (do Collection)))
(let recursive:array:has (lambda Atom (do Atom)))
(let array:has? (lambda Collection (lambda Any (do Unknown)) (do Atom)))
(let recursive:array:reverse (lambda Atom Collection (do Unknown)))
(let array:reverse (lambda Collection (do Unknown)))
(let array:append! (lambda Collection Unknown (do Collection)))
(let array:set-and-get! (lambda Collection Atom Unknown (do Unknown)))
(let array:tail! (lambda Collection (do Collection)))
(let array:push! (lambda Collection Unknown (do Unknown)))
(let l Any)
(let array:pop! (lambda Collection (do Any)))
(let array:even-indexed (lambda Collection (do Unknown)))
(let array:odd-indexed (lambda Collection (do Unknown)))
(let sorted Collection)
(let index Any)
(let array:unique (lambda Collection (do Collection)))
(let array:iterate (lambda Collection Unknown (do Collection)))
(let array:empty? (lambda Collection (do Atom)))
(let array:not-empty? (lambda Collection (do Atom)))
(let array:count-of (lambda Collection Unknown (do Atom)))
(let array:count (lambda Collection Atom (do Atom)))
(let recursive:array:empty! (lambda  (do Atom)))
(let array:empty! (lambda Collection (do Atom)))
(let array:in-bounds? (lambda Collection Atom (do Atom)))
(let get-option (lambda Collection Atom (do Collection)))
(let bounds Atom)
(let recursive:array:slice (lambda Atom Collection (do Unknown)))
(let array:slice (lambda Collection Atom Atom (do Collection)))
(let car (lambda Collection (do Any)))
(let bounds Atom)
(let recursive:cdr (lambda Atom Collection (do Unknown)))
(let cdr (lambda Collection (do Unknown)))
(let out Collection)
(let cons (lambda Collection Collection (do Collection)))
(let array:take (lambda Unknown Unknown (do Collection)))
(let array:drop (lambda Collection Unknown (do Collection)))
(let index Atom)
(let current Any)
(let recursive:array:binary-search (lambda Collection Atom Atom Atom (do Atom)))
(let array:binary-search (lambda Collection Atom (do Atom)))
(let recursive:array:zip (lambda Atom Atom Collection (do Unknown)))
(let array:zip (lambda Collection Collection (do Unknown)))
(let array:unzip (lambda Unknown (do Collection)))
(let array:equal? (lambda Collection Collection (do Atom)))
(let array:not-equal? (lambda Collection Collection (do Atom)))
(let array:join (lambda Collection Collection (do Collection)))
(let array:chars (lambda Collection (do Collection)))
(let array:lines (lambda Collection (do Collection)))
(let array:commas (lambda Collection (do Collection)))
(let array:spaces (lambda Collection (do Collection)))
(let array:dots (lambda Collection (do Collection)))
(let array:colons (lambda Collection (do Collection)))
(let array:semi-colons (lambda Collection (do Collection)))
(let array:dashes (lambda Collection (do Collection)))
(let array:flat-one (lambda Collection (do Collection)))
(let flatten (lambda Collection (do Collection)))
(let array:flat (lambda Collection (do Collection)))
(let pivot Any)
(let current Any)
(let predicate Atom)
(let left Collection)
(let right Collection)
(let recursive:array:sort (lambda Atom Atom Unknown Unknown (do Collection)))
(let sorted Collection)
(let left Any)
(let right Any)
(let array:sort (lambda Collection (lambda Any Any (do Unknown)) (do Atom)))
(let array:sorted-ascending? (lambda Collection (do Atom)))
(let array:sorted-descending? (lambda Collection (do Atom)))
(let array:sorted-by? (lambda Collection (lambda Unknown Any (do Atom)) (do Atom)))
(let array:increment! (lambda Collection Atom Atom (do Collection)))
(let array:set (lambda Collection Atom Unknown (do Collection)))
(let set (lambda Collection Atom Unknown (do Collection)))
(let array:sliding-window (lambda Collection Atom (do Unknown)))
(let len Atom)
(let recursive:array:adjacent-difference (lambda Atom Collection (do Atom)))
(let array:adjacent-difference (lambda Collection (lambda Any Any (do Unknown)) (do Atom)))
(let x Any)
(let i Any)
(let array:partition (lambda Collection Atom (do Collection)))
(let array:ranges (lambda Collection (lambda Unknown (do Unknown)) (do Unknown)))
(let start Any)
(let end Any)
(let array:chunks (lambda Collection Unknown (do Collection)))
(let len Atom)
(let prev Any)
(let current Any)
(let recursive:array:adjacent-find (lambda Atom (do Any)))
(let array:adjacent-find (lambda Collection (lambda Unknown Unknown (do Unknown)) (do Atom)))
(let coords Collection)
(let matrix:points (lambda Collection (lambda Unknown (do Unknown)) (do Collection)))
(let matrix:for (lambda Collection Unknown (do Unknown)))
(let matrix:shallow-copy (lambda Unknown (do Collection)))
(let coords Collection)
(let idx Atom)
(let predicate? Atom)
(let matrix:find-index (lambda Collection Unknown (do Collection)))
(let coords Collection)
(let matrix:find (lambda Collection Unknown (do Any)))
(let width Atom)
(let height Atom)
(let matrix:enumerated-for (lambda Collection (lambda Any Atom Atom (do Unknown)) (do Unknown)))
(let width Atom)
(let height Atom)
(let matrix:of (lambda Collection (lambda Unknown Unknown (do Unknown)) (do Collection)))
(let len Atom)
(let out Collection)
(let recursive:inner:matrix:rotate-square (lambda Atom (do Atom)))
(let recursive:outer:matrix:rotate-square (lambda Atom (do Atom)))
(let matrix:rotate-square (lambda Collection (do Collection)))
(let len Atom)
(let out Collection)
(let recursive:inner:matrix:flip-square (lambda Atom (do Atom)))
(let recursive:outer:matrix:flip-square (lambda Atom (do Atom)))
(let matrix:flip-square (lambda Collection (do Collection)))
(let matrix:dimensions (lambda Collection (do Collection)))
(let matrix:in-bounds? (lambda Collection Atom Unknown (do Atom)))
(let matrix:diagonal-neighborhood Collection)
(let matrix:moore-neighborhood Collection)
(let matrix:von-neumann-neighborhood Collection)
(let dy Atom)
(let dx Atom)
(let matrix:adjacent (lambda Collection Collection Atom Atom (lambda Any Collection Atom Atom (do Unknown)) (do Collection)))
(let dy Atom)
(let dx Atom)
(let matrix:adjacent-sum (lambda Collection Collection Atom Atom (lambda Unknown Any (do Unknown)) (do Collection)))
(let dy Atom)
(let dx Atom)
(let matrix:sliding-adjacent-sum (lambda Collection Collection Atom Atom Atom (lambda Unknown Any (do Unknown)) (do Collection)))
(let matrix:set! (lambda Collection Atom Atom Unknown (do Collection)))
(let matrix:get (lambda Collection Atom Atom (do Any)))
(let matrix:set-and-get! (lambda Collection Atom Atom Unknown (do Unknown)))
(let matrix:get-option (lambda Collection Atom Atom (do Collection)))
(let from:yx->key (lambda Unknown Unknown (do Unknown)))
(let from:string-or-number->key (lambda Collection (do Collection)))
(let recursive:from:list->array (lambda Collection Collection (do Unknown)))
(let from:list->array (lambda Collection (do Unknown)))
(let recursive:from:array->list (lambda Collection Unknown (do Unknown)))
(let from:array->list (lambda Collection (do Unknown)))
(let from:digit->char (lambda Atom (do Atom)))
(let from:char->digit (lambda Atom (do Atom)))
(let from:chars->digits (lambda Unknown (do Collection)))
(let current-sign Collection)
(let from:chars->positive-or-negative-digits (lambda Collection (do Collection)))
(let from:digits->chars (lambda Unknown (do Collection)))
(let recursive:from:digits->integer (lambda Atom Atom Atom (do Unknown)))
(let from:digits->integer (lambda Collection (do Unknown)))
(let negative? Atom)
(let digits Collection)
(let recursive:from:positive-or-negative-digits->integer (lambda Atom Atom Atom (do Atom)))
(let from:positive-or-negative-digits->integer (lambda Unknown (do Atom)))
(let from:positive-or-negative-digits->chars (lambda Collection (do Collection)))
(let recursive:from:integer->digits (lambda Atom Collection (do Any)))
(let from:integer->digits (lambda Atom (do Collection)))
(let negative? Atom)
(let num Atom)
(let recursive:from:number->positive-or-negative-digits (lambda Atom Collection (do Any)))
(let out Collection)
(let from:number->positive-or-negative-digits (lambda Atom (do Collection)))
(let recursive:from:number->bits (lambda Atom Collection (do Any)))
(let from:number->bits (lambda Atom (do Collection)))
(let from:numbers->chars (lambda Unknown (do Collection)))
(let from:chars->integer (lambda Unknown (do Unknown)))
(let from:positive-or-negative-chars->integer (lambda Collection (do Atom)))
(let from:string->integer (lambda Collection (do Atom)))
(let from:strings->integers (lambda Unknown (do Collection)))
(let dec Atom)
(let neg? Atom)
(let left Collection)
(let right Collection)
(let n Any)
(let sign Atom)
(let exponent Atom)
(let mantissa Atom)
(let from:string->float (lambda Collection (do Atom)))
(let from:strings->floats (lambda Unknown (do Collection)))
(let flip Atom)
(let exponent Atom)
(let mantisa Atom)
(let left Collection)
(let right Collection)
(let len Atom)
(let recursive:while (lambda Atom (do Atom)))
(let from:float->string (lambda Atom (do Collection)))
(let from:floats->strings (lambda Unknown (do Collection)))
(let from:string->date (lambda Collection (do Collection)))
(let from:integer->string (lambda Atom (do Collection)))
(let from:integers->strings (lambda Unknown (do Collection)))
(let s Collection)
(let from:array->set (lambda Collection (do Collection)))
(let s Collection)
(let from:array->table (lambda Collection (do Collection)))
(let from:set->array (lambda Collection (do Collection)))
(let from:map->array (lambda Collection (do Collection)))
(let from:set->integers (lambda Collection (do Collection)))
(let q Collection)
(let half Atom)
(let recursive:left:from:array->brray (lambda Atom (do Collection)))
(let recursive:right:from:array->brray (lambda Atom Atom (do Collection)))
(let from:array->brray (lambda Collection (do Collection)))
(let out Collection)
(let recursive:from:brray->array (lambda Atom Atom (do Atom)))
(let from:brray->array (lambda Collection (do Collection)))
(let from:matrix->string (lambda Collection (do Collection)))
(let array:shallow-copy (lambda Collection (do Collection)))
(let array:deep-copy (lambda Collection (do Collection)))
(let array:merge! (lambda Collection Collection (do Collection)))
(let out Collection)
(let array:merge (lambda Collection Collection (do Collection)))
(let array:concat (lambda Collection (do Collection)))
(let array:concat-with (lambda Collection Unknown (do Unknown)))
(let string:concat-with-lines (lambda Collection (do Unknown)))
(let array:swap-remove! (lambda Collection Atom (do Collection)))
(let temp Any)
(let array:swap! (lambda Collection Atom Atom (do Collection)))
(let recursive:array:index-of (lambda Atom (do Atom)))
(let array:index-of (lambda Collection Atom (do Atom)))
(let array:enumerate (lambda Collection (do Unknown)))
(let recursive:array:enumerated-map (lambda Atom Collection (do Unknown)))
(let array:enumerated-map (lambda Collection (lambda Any Atom (do Unknown)) (do Unknown)))
(let recursive:array:enumerated-select (lambda Atom Collection (do Unknown)))
(let array:enumerated-select (lambda Collection (lambda Any Atom (do Unknown)) (do Unknown)))
(let recursive:array:enumerated-exclude (lambda Atom Collection (do Unknown)))
(let array:enumerated-exclude (lambda Collection (lambda Any Atom (do Atom)) (do Unknown)))
(let recursive:array:enumerated-fold (lambda Atom Unknown (do Unknown)))
(let array:enumerated-fold (lambda Collection (lambda Unknown Any Atom (do Unknown)) Unknown (do Unknown)))
(let recursive:array:enumerated-find (lambda Atom (do Any)))
(let array:enumerated-find (lambda Collection (lambda Any Atom (do Unknown)) (do Any)))
(let recursive:array:enumerated-find-index (lambda Atom (do Atom)))
(let array:enumerated-find-index (lambda Collection (lambda Any Atom (do Unknown)) (do Atom)))
(let recursive:array:enumerated-every? (lambda Atom (do Atom)))
(let array:enumerated-every? (lambda Collection (lambda Any Atom (do Atom)) (do Atom)))
(let recursive:array:enumerated-some? (lambda Atom (do Atom)))
(let array:enumerated-some? (lambda Collection (lambda Any Atom (do Atom)) (do Atom)))
(let recursive:array:find-index (lambda Atom (do Atom)))
(let array:find-index (lambda Collection (lambda Any (do Unknown)) (do Atom)))
(let array:remove (lambda Collection Atom (do Collection)))
(let array:pad-right (lambda Collection Collection (do Collection)))
(let array:pad-left (lambda Collection Collection (do Collection)))
(let array:pad-right! (lambda Collection Collection (do Collection)))
(let array:pad-left! (lambda Collection Collection (do Collection)))
(let array:rotate-right (lambda Collection Atom (do Collection)))
(let array:rotate-left (lambda Collection Atom (do Collection)))
(let xs Collection)
(let bitmask Collection)
(let zero Atom)
(let count Collection)
(let at-least-one Collection)
(let ch Any)
(let code Atom)
(let mask Atom)
(let recursive:string:character-occurances (lambda Atom Atom (do Atom)))
(let string:character-occurances (lambda Collection Atom (do Atom)))
(let index Atom)
(let string:slice-from (lambda Collection Collection (do Collection)))
(let index Atom)
(let string:slice-after (lambda Collection Collection (do Collection)))
(let a Collection)
(let b Collection)
(let index Atom)
(let string:slice-to (lambda Collection Collection (do Collection)))
(let a Collection)
(let b Collection)
(let index Atom)
(let string:slice-before (lambda Collection Collection (do Collection)))
(let prev Any)
(let string:split (lambda Collection Unknown (do Collection)))
(let recursive:string:match (lambda Collection Atom (do Atom)))
(let string:match (lambda Collection Collection (do Atom)))
(let recursive:string:has (lambda Collection Atom (do Atom)))
(let string:has? (lambda Collection Collection (do Atom)))
(let a Any)
(let b Any)
(let pairs Collection)
(let is Collection)
(let current Any)
(let recursive:string:lesser (lambda  (do Atom)))
(let string:lesser? (lambda Collection Collection (do Atom)))
(let a Any)
(let b Any)
(let pairs Collection)
(let is Collection)
(let current Any)
(let recursive:string:greater (lambda  (do Atom)))
(let string:greater? (lambda Collection Collection (do Atom)))
(let string:greater-or-equal? (lambda Collection Collection (do Atom)))
(let string:lesser-or-equal? (lambda Collection Collection (do Atom)))
(let string:equal? (lambda Collection Collection (do Atom)))
(let string:not-equal? (lambda Unknown Unknown (do Atom)))
(let string:one-equal? (lambda Unknown Unknown (do Atom)))
(let string:two-equal? (lambda Collection Collection (do Atom)))
(let string:three-equal? (lambda Collection Collection (do Atom)))
(let string:min (lambda Collection Collection (do Unknown)))
(let string:max (lambda Collection Collection (do Unknown)))
(let M Atom)
(let row-delimiter2 Collection)
(let row-delimiter Collection)
(let string:join-as-table-with (lambda Collection Collection Unknown (do Collection)))
(let string:starts-with? (lambda Collection Collection (do Atom)))
(let string:ends-with? (lambda Collection Collection (do Atom)))
(let M Atom)
(let string:join-as-table (lambda Collection (do Collection)))
(let tr Collection)
(let string:trim-left (lambda Collection (do Collection)))
(let tr Collection)
(let string:trim-right (lambda Collection (do Collection)))
(let string:trim (lambda Collection (do Collection)))
(let string:lines (lambda Unknown (do Collection)))
(let string:chars (lambda Collection (do Collection)))
(let string:words (lambda Unknown (do Collection)))
(let string:commas (lambda Unknown (do Collection)))
(let string:dots (lambda Unknown (do Collection)))
(let string:colons (lambda Unknown (do Collection)))
(let string:semi-colons (lambda Collection (do Collection)))
(let string:dashes (lambda Collection (do Collection)))
(let string:multilines (lambda Unknown (do Collection)))
(let string:append (lambda Collection Collection (do Collection)))
(let string:prepend (lambda Collection Collection (do Collection)))
(let n Atom)
(let recursive:string:pad-left (lambda Atom Collection (do Unknown)))
(let string:pad-left (lambda Collection Atom Collection (do Unknown)))
(let n Atom)
(let recursive:string:pad-right (lambda Atom Collection (do Unknown)))
(let string:pad-right (lambda Collection Atom Collection (do Unknown)))
(let xs Collection)
(let n Atom)
(let current-char Any)
(let recursive:string:upper (lambda Atom (do Atom)))
(let string:upper (lambda Collection (do Collection)))
(let xs Collection)
(let n Atom)
(let current-char Any)
(let recursive:string:lower (lambda Atom (do Atom)))
(let string:lower (lambda Collection (do Collection)))
(let new:map (lambda Collection (do Unknown)))
(let new:set (lambda Collection (do Collection)))
(let new:set4 (lambda  (do Collection)))
(let new:set8 (lambda  (do Collection)))
(let new:set16 (lambda  (do Collection)))
(let new:set32 (lambda  (do Collection)))
(let new:set64 (lambda  (do Collection)))
(let new:map4 (lambda  (do Collection)))
(let new:map8 (lambda  (do Collection)))
(let new:map16 (lambda  (do Collection)))
(let new:map32 (lambda  (do Collection)))
(let new:map64 (lambda  (do Collection)))
(let new:array (lambda Collection (do Collection)))
(let new:list (lambda Unknown (do Collection)))
(let new:set-n (lambda Atom (do Collection)))
(let new:date (lambda Unknown Unknown Unknown (do Collection)))
(let new:heap Collection)
(let new:brray (lambda  (do Collection)))
(let new:queue (lambda  (do Collection)))
(let new:stack (lambda  (do Collection)))
(let xs Collection)
(let new:binary-tree (lambda Unknown (do Collection)))
(let binary-tree:left (lambda Collection (do Any)))
(let binary-tree:right (lambda Collection (do Any)))
(let binary-tree:left! (lambda Collection Unknown (do Collection)))
(let binary-tree:right! (lambda Collection Unknown (do Collection)))
(let binary-tree:value (lambda Collection (do Any)))
(let prime-num Atom)
(let total Collection)
(let letter Any)
(let recursive:set:index (lambda Atom Atom (do Any)))
(let set:index (lambda Collection Collection (do Any)))
(let idx Any)
(let current Any)
(let len Atom)
(let index Atom)
(let entry Collection)
(let set:add! (lambda Collection Collection (do Collection)))
(let idx Any)
(let current Any)
(let len Atom)
(let index Atom)
(let entry Collection)
(let set:remove! (lambda Collection Collection (do Collection)))
(let idx Atom)
(let current Any)
(let set:has? (lambda Collection Collection (do Atom)))
(let set:exists? (lambda Collection Collection (do Atom)))
(let set:not-exists? (lambda Collection Collection (do Atom)))
(let set:add-and-get! (lambda Collection Collection (do Collection)))
(let set:remove-and-get! (lambda Collection Collection (do Collection)))
(let set:with! (lambda Unknown Collection (do Collection)))
(let set:max-capacity (lambda Collection Collection (do Collection)))
(let set:min-capacity (lambda Collection Collection (do Collection)))
(let set:values (lambda Collection (do Collection)))
(let set:intersection (lambda Collection Collection (do Collection)))
(let set:difference (lambda Collection Collection (do Collection)))
(let out Collection)
(let set:xor (lambda Collection Collection (do Collection)))
(let out Collection)
(let set:union (lambda Collection Collection (do Collection)))
(let set:empty! (lambda Collection (do Collection)))
(let map:with! (lambda Unknown Collection (do Unknown)))
(let map:empty! (lambda Collection (do Collection)))
(let map:keys (lambda Collection (do Collection)))
(let map:values (lambda Collection (do Collection)))
(let idx Any)
(let current Any)
(let len Atom)
(let index Atom)
(let entry Collection)
(let map:set! (lambda Collection Collection Unknown (do Collection)))
(let idx Any)
(let current Any)
(let len Atom)
(let index Atom)
(let map:remove! (lambda Collection Collection (do Collection)))
(let map:set-and-get! (lambda Collection Collection Unknown (do Unknown)))
(let value Collection)
(let map:remove-and-get! (lambda Collection Collection (do Collection)))
(let idx Atom)
(let current Any)
(let found-index Atom)
(let map:get (lambda Collection Collection (do Collection)))
(let idx Atom)
(let current Any)
(let index Atom)
(let map:get-option (lambda Collection Collection (do Collection)))
(let idx Atom)
(let current Collection)
(let map:has? (lambda Collection Collection (do Atom)))
(let map:exists? (lambda Collection Collection (do Atom)))
(let map:not-exists? (lambda Collection Collection (do Atom)))
(let map:count (lambda Collection (do Collection)))
(let doubly-linked-list:prev! (lambda Collection Collection (do Collection)))
(let doubly-linked-list:next! (lambda Collection Collection (do Collection)))
(let doubly-linked-list:prev (lambda Collection (do Any)))
(let doubly-linked-list:next (lambda Collection (do Any)))
(let doubly-linked-list:value (lambda Collection (do Any)))
(let var:def (lambda Unknown (do Collection)))
(let var:get (lambda Collection (do Any)))
(let var:set! (lambda Collection Unknown (do Collection)))
(let var:del! (lambda Collection (do Collection)))
(let var:set-and-get! (lambda Collection Unknown (do Unknown)))
(let var:increment! (lambda Collection (do Collection)))
(let var:decrement! (lambda Collection (do Collection)))
(let var:increment-and-get! (lambda Collection (do Any)))
(let var:decrement-and-get! (lambda Collection (do Any)))
(let bool:def (lambda Unknown (do Collection)))
(let bool:get (lambda Collection (do Any)))
(let bool:set! (lambda Collection Unknown (do Collection)))
(let bool:toggle! (lambda Collection (do Collection)))
(let bool:true (lambda  (do Collection)))
(let bool:false (lambda  (do Collection)))
(let bool:true! (lambda Collection (do Collection)))
(let bool:false! (lambda Collection (do Collection)))
(let bool:true? (lambda Collection (do Atom)))
(let bool:false? (lambda Collection (do Atom)))
(let curry:ternary (lambda (lambda Unknown Unknown Unknown (do Unknown)) Unknown Unknown (do Abstraction)))
(let curry:binary (lambda (lambda Unknown Unknown (do Unknown)) Unknown (do Abstraction)))
(let curry:unary (lambda (lambda Unknown (do Unknown)) (do Abstraction)))
(let curry:three (lambda (lambda Unknown Unknown Unknown (do Unknown)) Unknown Unknown (do Abstraction)))
(let curry:two (lambda (lambda Unknown Unknown (do Unknown)) Unknown (do Abstraction)))
(let curry:one (lambda (lambda Unknown (do Unknown)) (do Abstraction)))
(let brray:offset-left (lambda Collection (do Atom)))
(let brray:offset-right (lambda Collection (do Atom)))
(let brray:length (lambda Collection (do Atom)))
(let brray:empty? (lambda Collection (do Atom)))
(let brray:empty! (lambda Collection (do Collection)))
(let offset-index Atom)
(let index Atom)
(let brray:get (lambda Collection Atom (do Any)))
(let offset Atom)
(let brray:set! (lambda Collection Atom Unknown (do Collection)))
(let c Any)
(let brray:add-to-left! (lambda Collection Unknown (do Collection)))
(let c Any)
(let brray:add-to-right! (lambda Collection Unknown (do Collection)))
(let len Atom)
(let brray:remove-from-left! (lambda Collection (do Atom)))
(let len Atom)
(let brray:remove-from-right! (lambda Collection (do Atom)))
(let recursive:brray:iter (lambda Atom Atom (do Atom)))
(let brray:iter (lambda Collection (lambda Any (do Unknown)) (do Atom)))
(let result Collection)
(let len Atom)
(let half Atom)
(let recursive:left:brray:map (lambda Atom (do Atom)))
(let recursive:right:brray:map (lambda Atom Atom (do Atom)))
(let brray:map (lambda Collection (lambda Any (do Unknown)) (do Collection)))
(let brray:balance? (lambda Collection (do Atom)))
(let initial Collection)
(let half Atom)
(let recursive:left:brray:balance! (lambda Atom (do Atom)))
(let recursive:right:brray:balance! (lambda Atom Atom (do Atom)))
(let brray:balance! (lambda Collection (do Atom)))
(let brray:append! (lambda Collection Unknown (do Unknown)))
(let brray:prepend! (lambda Collection Unknown (do Unknown)))
(let brray:head! (lambda Collection (do Unknown)))
(let brray:tail! (lambda Collection (do Unknown)))
(let brray:first (lambda Collection (do Any)))
(let brray:last (lambda Collection (do Any)))
(let last Any)
(let brray:pop-right! (lambda Collection (do Any)))
(let first Any)
(let brray:pop-left! (lambda Collection (do Any)))
(let N Atom)
(let recursive:brray:rotate-left! (lambda Atom Atom (do Atom)))
(let brray:rotate-left! (lambda Collection Atom (do Unknown)))
(let N Atom)
(let recursive:brray:rotate-left! (lambda Atom Atom (do Atom)))
(let brray:rotate-right! (lambda Collection Atom (do Unknown)))
(let len Atom)
(let start Atom)
(let end Atom)
(let slice Collection)
(let slice-len Atom)
(let half Atom)
(let recursive:left:brray:slice (lambda Atom (do Atom)))
(let recursive:right:brray:slice (lambda Atom Atom (do Atom)))
(let brray:slice (lambda Collection Atom Atom (do Collection)))
(let queue:empty? (lambda Collection (do Atom)))
(let queue:not-empty? (lambda Collection (do Atom)))
(let queue:empty! (lambda Collection (do Collection)))
(let queue:enqueue! (lambda Collection Unknown (do Unknown)))
(let queue:dequeue! (lambda Collection (do Unknown)))
(let queue:peek (lambda Collection (do Any)))
(let stack:empty? (lambda Collection (do Atom)))
(let stack:not-empty? (lambda Collection (do Atom)))
(let stack:empty! (lambda Collection (do Collection)))
(let stack:push! (lambda Collection Unknown (do Unknown)))
(let stack:pop! (lambda Collection (do Unknown)))
(let stack:peek (lambda Collection (do Any)))
(let time:add-seconds (lambda Atom Atom (do Atom)))
(let time:add-minutes (lambda Atom Atom (do Atom)))
(let time:add-hours (lambda Atom Atom (do Atom)))
(let time:add-days (lambda Atom Atom (do Atom)))
(let time:add-months (lambda Atom Atom (do Atom)))
(let time:add-years (lambda Atom Atom (do Atom)))
(let time:sub-seconds (lambda Atom Atom (do Atom)))
(let time:sub-minutes (lambda Atom Atom (do Atom)))
(let time:sub-hours (lambda Atom Atom (do Atom)))
(let time:sub-days (lambda Atom Atom (do Atom)))
(let time:sub-months (lambda Atom Atom (do Atom)))
(let time:sub-years (lambda Atom Atom (do Atom)))
(let date:year (lambda Collection (do Any)))
(let date:month (lambda Collection (do Any)))
(let date:day (lambda Collection (do Any)))
(let date:month-day (lambda Collection (do Unknown)))
(let date:year-month (lambda Collection (do Collection)))
(let recursive:loop:for-range (lambda Atom (do Atom)))
(let loop:for-range (lambda Atom Atom (lambda Atom (do Unknown)) (do Atom)))
(let recursive:loop:for-n (lambda Atom (do Atom)))
(let loop:for-n (lambda Atom (lambda Atom (do Unknown)) (do Atom)))
(let recursive:loop:repeat (lambda Atom (do Atom)))
(let loop:repeat (lambda Atom (lambda  (do Unknown)) (do Atom)))
(let recursive:loop:some-n (lambda Atom (do Atom)))
(let loop:some-n? (lambda Atom (lambda Atom (do Unknown)) (do Atom)))
(let recursive:loop:some-range (lambda Atom (do Atom)))
(let loop:some-range? (lambda Atom Atom (lambda Atom (do Unknown)) (do Atom)))
(let node:parent (lambda Atom (do Atom)))
(let node:left (lambda Atom (do Atom)))
(let node:right (lambda Atom (do Atom)))
(let heap:top Atom)
(let heap:greater? (lambda Collection Atom Atom (lambda Any Any (do Unknown)) (do Atom)))
(let node Collection)
(let recursive:heap:sift-up! (lambda  (do Atom)))
(let heap:sift-up! (lambda Collection Unknown (do Atom)))
(let node Collection)
(let max-child Atom)
(let recursive:heap:sift-down! (lambda  (do Atom)))
(let heap:sift-down! (lambda Collection Unknown (do Atom)))
(let heap:peek (lambda Collection (do Any)))
(let heap:push! (lambda Collection Unknown Unknown (do Collection)))
(let bottom Atom)
(let heap:pop! (lambda Collection Unknown (do Collection)))
(let heap:replace! (lambda Collection Unknown Unknown (do Collection)))
(let heap:empty? (lambda Collection (do Atom)))
(let heap:not-empty? (lambda Collection (do Atom)))
(let heap:empty! (lambda Collection (do Atom)))
(let heap Collection)
(let from:array->heap (lambda Collection Unknown (do Collection)))
(let optimization:tail-call-loop (lambda Collection (do Any)))
(let optimization:tail-calls-0 (lambda (lambda  (do Unknown)) (do Abstraction)))
(let optimization:tail-calls-1 (lambda (lambda Unknown (do Unknown)) (do Abstraction)))
(let optimization:tail-calls-2 (lambda (lambda Unknown Unknown (do Unknown)) (do Abstraction)))
(let optimization:tail-calls-3 (lambda (lambda Unknown Unknown Unknown (do Unknown)) (do Abstraction)))
(let optimization:tail-calls-4 (lambda (lambda Unknown Unknown Unknown Unknown (do Unknown)) (do Abstraction)))
(let option:error? (lambda Collection (do Atom)))
(let option:value? (lambda Collection (do Atom)))
(let option:value (lambda Collection (do Any)))
(let option:throw-error (lambda Collection (do Any)))
(let option:error (lambda Collection (do Any)))
(let array:get (lambda Collection Atom (do Any)))
(let array:length (lambda Collection (do Atom)))
(let array:set! (lambda Collection Atom Any (do Collection)))
(let array:remove-last! (lambda Collection (do Collection)))
(let del! (lambda Collection (do Collection)))
(let array:del! (lambda Collection (do Collection)))
(let equal? (lambda Collection Collection (do Atom)))
(let not-equal? (lambda Collection Collection (do Atom)))
(let array:at (lambda Collection Atom (do Any)))
(let array:head (lambda Collection (do Any)))
(let bounds Atom)
(let recursive:array:tail (lambda Atom Collection (do Unknown)))
(let array:tail (lambda Collection (do Unknown)))
(let array:car (lambda Collection (do Any)))
(let array:cdr (lambda Collection (do Unknown)))
(let array:for-range (lambda Atom Atom (lambda Atom (do Unknown)) (do Atom)))
(let π Atom)
(let λ (lambda ... Unknown (do Abstraction)))
(let array? (lambda Unknown (do Atom)))
(let char? (lambda Atom (do Atom)))
(let match:negative? (lambda Collection (do Atom)))
(let negative? Atom)
(let digits Any)
(let match:number? (lambda Collection (do Atom)))
(let match:digit? (lambda Atom (do Atom)))
(let match:digits? (lambda Collection (do Atom)))
(let ast:type Atom)
(let ast:value Atom)
(let ast:apply Atom)
(let ast:word Atom)
(let ast:atom Atom)
(let ast:leaf (lambda Unknown Unknown (do Collection)))
(let c Any)
(let ast:leaf? (lambda Collection (do Atom)))
(let tree Collection)
(let stack Collection)
(let head Collection)
(let acc Collection)
(let cursor Any)
(let temp Collection)
(let h Any)
(let token Collection)
(let h Any)
(let from:chars->ast (lambda Collection (do Collection)))
(let name Any)
(let val Unknown)
(let special-form:let (lambda Collection Collection (do Unknown)))
(let params Collection)
(let body Any)
(let local Collection)
(let special-form:lambda (lambda Collection Unknown (do Abstraction)))
(let application (lambda Unknown Unknown (do Unknown)))
(let special-form:apply (lambda Collection Unknown (do Unknown)))
(let special-form:array (lambda Collection Collection (do Collection)))
(let special-form:length (lambda Collection Unknown (do Atom)))
(let special-form:get (lambda Collection Unknown (do Any)))
(let special-form:set! (lambda Collection Unknown (do Collection)))
(let special-form:pop! (lambda Collection Unknown (do Collection)))
(let special-form:equal? (lambda Collection Unknown (do Atom)))
(let special-form:add (lambda Collection Unknown (do Atom)))
(let special-form:subtract (lambda Collection Unknown (do Atom)))
(let special-form:multiply (lambda Collection Unknown (do Atom)))
(let special-form:divide (lambda Collection Unknown (do Atom)))
(let special-form:greater-than? (lambda Collection Unknown (do Atom)))
(let special-form:less-than? (lambda Collection Unknown (do Atom)))
(let special-form:greater-than-or-equal? (lambda Collection Unknown (do Atom)))
(let special-form:less-than-or-equal? (lambda Collection Unknown (do Atom)))
(let special-form:mod (lambda Collection Unknown (do Atom)))
(let special-form:bit-wise-and (lambda Collection Unknown (do Atom)))
(let special-form:bit-wise-or (lambda Collection Unknown (do Atom)))
(let special-form:bit-wise-xor (lambda Collection Unknown (do Atom)))
(let special-form:bit-wise-right-shift (lambda Collection Unknown (do Atom)))
(let special-form:bit-wise-left-shift (lambda Collection Unknown (do Atom)))
(let special-form:bit-wise-not (lambda Collection Unknown (do Atom)))
(let special-form:do (lambda Collection Collection (do Any)))
(let special-form:if (lambda Collection Unknown (do Collection)))
(let special-form:and? (lambda Collection Collection (do Atom)))
(let special-form:or? (lambda Collection Collection (do Atom)))
(let special-form:throw (lambda Collection Collection (do Any)))
(let special-form:loop (lambda Collection Collection (do Atom)))
(let special-form:atom? (lambda Collection Collection (do Atom)))
(let special-form:lambda? (lambda Collection Collection (do Atom)))
(let keywords Collection)
(let head Any)
(let tail Any)
(let prototype:get (lambda Collection Collection (do Collection)))
(let prototype:create! (lambda Unknown (do Unknown)))
(let expression Collection)
(let head Any)
(let tail Unknown)
(let pattern Any)
(let evaluate (lambda Collection Collection (do Collection)))
(let type Any)
(let value Any)
(let ast:stringify (lambda Collection (do Collection)))
(let ast:get-name (lambda Collection (do Any)))
(let expression Collection)
(let head Any)
(let tail Collection)
(let pattern Any)
(let ast:traverse (lambda Collection Unknown (lambda Any (do Unknown)) (lambda Any (do Unknown)) (lambda Any Collection (do Unknown)) (do Collection)))
(let lisp:parse (lambda Unknown (do Collection)))
(let lisp:eval (lambda Unknown (do Atom)))
(let lambda::annonymous::1 (lambda Collection Collection Atom (do Collection)))
(let lambda::annonymous::1 (lambda Collection Collection Atom (do Collection)))
(let lambda::annonymous::1 (lambda Atom (do Atom)))
(let lambda::annonymous::1 (lambda Unknown (do Unknown)))
(let lambda::annonymous::1 (lambda Unknown (do Atom)))
(let lambda::annonymous::1 (lambda Unknown (do Unknown)))
(let lambda::annonymous::1 (lambda Atom (do Unknown)))
(let lambda::annonymous::1 (lambda Atom (do Atom)))
(let lambda::annonymous::1 (lambda Atom (do Unknown)))
(let idx Atom)
(let predicate? Atom)
(let lambda::annonymous::1 (lambda Collection (do Atom)))
(let lambda::annonymous::1 (lambda Unknown Unknown Unknown (do Atom)))
(let lambda::annonymous::1 (lambda Collection Unknown Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Unknown Unknown Atom (do Collection)))
(let lambda::annonymous::1 (lambda Unknown Atom (do Atom)))
(let lambda::annonymous::1 (lambda Atom Atom (do Atom)))
(let lambda::annonymous::1 (lambda Atom Atom (do Atom)))
(let lambda::annonymous::1 (lambda Atom Atom (do Atom)))
(let lambda::annonymous::1 (lambda Collection Unknown Atom (do Collection)))
(let lambda::annonymous::1 (lambda Collection Unknown Atom (do Collection)))
(let lambda::annonymous::1 (lambda Atom (do Unknown)))
(let lambda::annonymous::1 (lambda Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Collection Atom (do Collection)))
(let lambda::annonymous::1 (lambda Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Collection Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Atom Collection (do Atom)))
(let lambda::annonymous::1 (lambda Atom Collection (do Atom)))
(let lambda::annonymous::1 (lambda Collection Atom Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Collection Atom Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Atom Atom (do Atom)))
(let lambda::annonymous::1 (lambda Atom Atom (do Atom)))
(let lambda::annonymous::2 (lambda Atom (do Atom)))
(let lambda::annonymous::2 (lambda Atom (do Any)))
(let lambda::annonymous::1 (lambda Unknown Atom (do Atom)))
(let lambda::annonymous::1 (lambda Unknown Atom (do Collection)))
(let lambda::annonymous::1 (lambda Collection (do Collection)))
(let lambda::annonymous::1 (lambda Atom Unknown (do Atom)))
(let lambda::annonymous::1 (lambda Unknown Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Collection Unknown (do Unknown)))
(let lambda::annonymous::1 (lambda Atom Unknown (do Atom)))
(let lambda::annonymous::1 (lambda Atom (do Atom)))
(let lambda::annonymous::1 (lambda Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Collection Collection (do Collection)))
(let lambda::annonymous::1 (lambda Unknown Collection (do Collection)))
(let lambda::annonymous::1 (lambda Unknown Collection (do Collection)))
(let lambda::annonymous::1 (lambda Unknown Collection (do Collection)))
(let lambda::annonymous::1 (lambda Unknown Collection (do Collection)))
(let lambda::annonymous::1 (lambda Unknown Collection (do Collection)))
(let lambda::annonymous::1 (lambda Unknown Collection (do Collection)))
(let lambda::annonymous::1 (lambda Unknown Collection (do Collection)))
(let lambda::annonymous::1 (lambda Unknown Collection (do Collection)))
(let lambda::annonymous::1 (lambda Collection Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Collection Collection (do Collection)))
(let x Any)
(let i Any)
(let lambda::annonymous::1 (lambda Collection Collection (do Unknown)))
(let lambda::annonymous::1 (lambda Collection (do Collection)))
(let dy Atom)
(let dx Atom)
(let lambda::annonymous::1 (lambda Collection (do Collection)))
(let dy Atom)
(let dx Atom)
(let lambda::annonymous::1 (lambda Unknown Collection (do Unknown)))
(let dy Atom)
(let dx Atom)
(let lambda::annonymous::1 (lambda Unknown Collection (do Unknown)))
(let lambda::annonymous::1 (lambda Atom (do Collection)))
(let lambda::annonymous::1 (lambda Collection (do Collection)))
(let lambda::annonymous::1 (lambda Collection Atom (do Unknown)))
(let lambda::annonymous::1 (lambda Collection Collection (do Collection)))
(let lambda::annonymous::1 (lambda Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Collection (do Collection)))
(let lambda::annonymous::1 (lambda Collection (do Collection)))
(let lambda::annonymous::1 (lambda Collection Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Collection Collection (do Collection)))
(let lambda::annonymous::1 (lambda Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Collection Atom (do Collection)))
(let lambda::annonymous::1 (lambda Collection Collection (do Collection)))
(let lambda::annonymous::1 (lambda Collection Collection (do Collection)))
(let lambda::annonymous::1 (lambda Collection (do Unknown)))
(let lambda::annonymous::1 (lambda Collection Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Collection (do Unknown)))
(let lambda::annonymous::1 (lambda Collection (do Unknown)))
(let lambda::annonymous::1 (lambda Collection (do Collection)))
(let lambda::annonymous::1 (lambda Collection (do Unknown)))
(let lambda::annonymous::1 (lambda Collection Atom (do Atom)))
(let lambda::annonymous::1 (lambda Collection Atom (do Atom)))
(let lambda::annonymous::1 (lambda Collection Unknown Atom (do Collection)))
(let lambda::annonymous::1 (lambda Collection Collection (do Collection)))
(let lambda::annonymous::1 (lambda Collection (do Atom)))
(let lambda::annonymous::1 (lambda Collection (do Atom)))
(let lambda::annonymous::1 (lambda Collection Collection (do Collection)))
(let lambda::annonymous::1 (lambda Collection Collection (do Unknown)))
(let lambda::annonymous::1 (lambda Collection Collection (do Unknown)))
(let lambda::annonymous::1 (lambda Collection (do Atom)))
(let lambda::annonymous::1 (lambda Collection (do Collection)))
(let lambda::annonymous::1 (lambda Collection Unknown Atom (do Collection)))
(let lambda::annonymous::1 (lambda Collection (do Atom)))
(let lambda::annonymous::1 (lambda Collection (do Atom)))
(let lambda::annonymous::1 (lambda Collection Collection (do Collection)))
(let lambda::annonymous::1 (lambda Unknown (do Collection)))
(let cursor Any)
(let temp Collection)
(let h Any)
(let token Collection)
(let h Any)
(let lambda::annonymous::1 (lambda Atom (do Atom)))
(let lambda::annonymous::1 (lambda Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Collection Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Collection (do Unknown)))
(let lambda::annonymous::1 (lambda Atom (do Collection)))
(let lambda::annonymous::1 (lambda Atom (do Atom)))
(let lambda::annonymous::1 (lambda Collection (do Any)))
(let lambda::annonymous::1 (lambda Collection (do Atom)))
(let lambda::annonymous::1 (lambda Collection (do Atom)))
(let lambda::annonymous::1 (lambda Collection (do Atom)))
(let lambda::annonymous::1 (lambda Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Collection (do Atom)))
(let prev Any)
(let lambda::annonymous::1 (lambda Collection Unknown (do Collection)))
(let lambda::annonymous::1 (lambda Atom (do Atom)))
(let index Any)
(let lambda::annonymous::1 (lambda Collection (do Atom)))
(let lambda::annonymous::1 (lambda Collection (do Any)))