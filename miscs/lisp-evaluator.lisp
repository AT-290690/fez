(let keywords (new:map (array 
  "let" (lambda args env (do (let name (get (get args 0) ast:value)) (let val (evaluate (get args 1) env)) (map:set! env name val) val))
  "lambda" (lambda args env (do (let params (array:slice args 0 (- (length args) 1))) (let body (get args -1)) (lambda props scope (do (let local (array:deep-copy env)) (loop:for-n (length props) (lambda i (map:set! local (get (get params i) ast:value) (evaluate (get props i) scope)))) (evaluate body local)))))
  "apply" (lambda args env (do (let application (evaluate (array:head args) env)) (application (array:tail args) env)))
  "array" (lambda args env (array:map args (lambda arg (evaluate arg env))))
  "length" (lambda args env (length (evaluate (get args 0) env)))
  "get" (lambda args env (get (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "set!" (lambda args env (if (= (length args 3)) (set! (evaluate (get args 0) env) (evaluate (get args 1) env) (evaluate (get args 2) env)) (set! (evaluate (get args 0)))))
  "=" (lambda args env (= (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "+" (lambda args env (+ (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "-" (lambda args env (if (= (length args) 1) (- (evaluate (get args 0) env)) (- (evaluate (get args 0) env) (evaluate (get args 1) env))))
  "*" (lambda args env (* (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "/" (lambda args env (/ (evaluate (get args 0) env) (evaluate (get args 1) env)))
  ">" (lambda args env (> (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "<" (lambda args env (< (evaluate (get args 0) env) (evaluate (get args 1) env)))
  ">=" (lambda args env (>= (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "<=" (lambda args env (<= (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "mod" (lambda args env (mod (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "&" (lambda args env (& (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "|" (lambda args env (| (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "^" (lambda args env (^ (evaluate (get args 0) env) (evaluate (get args 1) env)))
  ">>" (lambda args env (>> (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "<<" (lambda args env (<< (evaluate (get args 0) env) (evaluate (get args 1) env)))
  ">>>" (lambda args env (>>> (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "~" (lambda args env (~ (evaluate (get args 0) env)))
  "do" (lambda args env (array:first (array:fold args (lambda a arg (array:set! a 0 (evaluate arg env))) ())))
  "if" (lambda args env (if (evaluate (get args 0) env) (evaluate (get args 1) env) (if (= (length args) 3) (evaluate (get args 2) env))))
  "and" (lambda args env (and (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "or" (lambda args env (or (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "atom?" (lambda args env (atom? (evaluate (get args 0) env)))
  "lambda?" (lambda args env (lambda? (evaluate (get args 0) env))))))

(let evaluate (lambda exp env (do 
  (let expression (if (and (array? exp) (ast:leaf? exp)) (array exp) exp))
  (if (array:not-empty? expression) (do 
    (let first (array:head expression))
    (let rest (array:tail expression))
    (let pattern (get first ast:type))
    (cond 
      (= pattern ast:word) (map:get env (get first ast:value))
      (= pattern ast:apply) (apply rest env (map:get env (get first ast:value)))
      (= pattern ast:atom) (get first ast:value)
      (*) ())) ()))))
