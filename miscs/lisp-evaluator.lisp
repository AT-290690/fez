(let keywords (new:map (array 
  "let" (lambda args env (do (let name (get (get args 0) ast:value)) (let val (evaluate (get args 1) env)) (map:set! env name val) val))
  "lambda" (lambda args env (do (let params (array:slice args 0 (- (length args) 1))) (let body (array:at args -1)) (lambda props scope (do (let local (array:deep-copy env)) (loop:for-n (length props) (lambda i (map:set! local (get (get params i) ast:value) (evaluate (get props i) scope)))) (evaluate body local)))))
  "apply" (lambda args env (do (let application (evaluate (array:head args) env)) (application (array:tail args) env)))
  "array" (lambda args env (array:map args (lambda arg (evaluate arg env))))
  "length" (lambda args env (length (evaluate (get args 0) env)))
  "get" (lambda args env (get (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "set!" (lambda args env (if (= (length args) 3) (set! (evaluate (get args 0) env) (evaluate (get args 1) env) (evaluate (get args 2) env)) (set! (evaluate (get args 0)))))
  "=" (lambda args env (= (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "+" (lambda args env (+ (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "-" (lambda args env (if (= (length args) 1) (- (evaluate (get args 0) env)) (- (evaluate (get args 0) env) (evaluate (get args 1) env))))
  "*" (lambda args env (* (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "/" (lambda args env (/ (evaluate (get args 0) env) (evaluate (get args 1) env)))
  ">" (lambda args env (> (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "<" (lambda args env (< (evaluate (get args 0) env) (evaluate (get args 1) env)))
  ">=" (lambda args env (>= (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "<=" (lambda args env (<= (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "mod" (lambda args env (mod (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "&" (lambda args env (& (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "|" (lambda args env (| (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "^" (lambda args env (^ (evaluate (get args 0) env) (evaluate (get args 1) env)))
  ">>" (lambda args env (>> (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "<<" (lambda args env (<< (evaluate (get args 0) env) (evaluate (get args 1) env)))
  ">>>" (lambda args env (>>> (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "~" (lambda args env (~ (evaluate (get args 0) env)))
  "do" (lambda args env (array:first (array:fold args (lambda a arg (array:set! a 0 (evaluate arg env))) ())))
  "if" (lambda args env (if (evaluate (get args 0) env) (evaluate (get args 1) env) (if (= (length args) 3) (evaluate (get args 2) env))))
  "and" (lambda args env (and (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "or" (lambda args env (or (evaluate (get args 0) env) (evaluate (get args 1) env)))
  "throw" (lambda args env (throw (evaluate (get args 0) env)))
  "atom?" (lambda args env (atom? (evaluate (get args 0) env)))
  "lambda?" (lambda args env (lambda? (evaluate (get args 0) env))))))

(let evaluate (lambda exp env (do 
  (let expression (if (and (array? exp) (ast:leaf? exp)) (array exp) exp))
  (if (array:not-empty? expression) (do 
    (let head (array:head expression))
    (let tail (array:tail expression))
    (let pattern (get head ast:type))
    (cond 
      (= pattern ast:word) (map:get env (get head ast:value))
      (= pattern ast:apply) (apply tail env (map:get env (get head ast:value)))
      (= pattern ast:atom) (get head ast:value)
      (*) ())) ()))))
     
; (apply (from:chars->ast "(let add (lambda a b (+ a b))) (add 1 2)") keywords (map:get keywords "do"))