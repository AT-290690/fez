(let keywords (array () () () () () () () ()))
(map:set! keywords "let" (lambda args env (do
  (let name (array:get (array:first args) ast:value))
  (let val (evaluate (array:second args) env))
  (map:set! env name val)
  val)))
(map:set! keywords "lambda" (lambda args env (do
  (let params (array:slice args 0 (- (length args) 1)))
  (let body (array:get args -1))
  (lambda props scope (do
  (let local (array:shallow-copy env))
  (loop:for-n (length props) (lambda i
    (map:set! local (get (get params i) ast:value) (evaluate (get props i) scope))))
  (evaluate body local))))))
(map:set! keywords "apply" (lambda args env (do (let application (evaluate (array:first args) env)) (application (array:tail args) env))))
(map:set! keywords "array" (lambda args env (array:map args (lambda arg (evaluate arg env)))))
(map:set! keywords "length" (lambda args env (length (evaluate (get args 0) env))))
(map:set! keywords "=" (lambda args env (= (evaluate (get args 0) env) (evaluate (get args 1) env))))
(map:set! keywords "+" (lambda args env (+ (evaluate (get args 0) env) (evaluate (get args 1) env))))
(map:set! keywords "-" (lambda args env (if (= (length args) 1) (- (evaluate (get args 0) env)) (- (evaluate (get args 0) env) (evaluate (get args 1) env)))))
(map:set! keywords "*" (lambda args env (* (evaluate (get args 0) env) (evaluate (get args 1) env))))
(map:set! keywords "/" (lambda args env (/ (evaluate (get args 0) env) (evaluate (get args 1) env))))
(map:set! keywords "mod" (lambda args env (mod (evaluate (get args 0) env) (evaluate (get args 1) env))))
(map:set! keywords "&" (lambda args env (& (evaluate (get args 0) env) (evaluate (get args 1) env))))
(map:set! keywords "|" (lambda args env (| (evaluate (get args 0) env) (evaluate (get args 1) env))))
(map:set! keywords "^" (lambda args env (^ (evaluate (get args 0) env) (evaluate (get args 1) env))))
(map:set! keywords ">>" (lambda args env (>> (evaluate (get args 0) env) (evaluate (get args 1) env))))
(map:set! keywords "<<" (lambda args env (<< (evaluate (get args 0) env) (evaluate (get args 1) env))))
(map:set! keywords ">>>" (lambda args env (>>> (evaluate (get args 0) env) (evaluate (get args 1) env))))
(map:set! keywords "~" (lambda args env (~ (evaluate (get args 0) env))))
(map:set! keywords "do" (lambda args env (array:first (array:fold args (lambda a arg (array:set! a 0 (evaluate arg env))) ()))))
(map:set! keywords "if" (lambda args env (if (evaluate (get args 0) env) (evaluate (get args 1) env) (if (= (length args) 3) (evaluate (get args 2) env)))))
(map:set! keywords "atom?" (lambda args env (atom? (evaluate (get args 0) env))))
(map:set! keywords "lambda?" (lambda args env (lambda? (evaluate (get args 0) env))))

(let run (lambda source (apply (map:get keywords "do") (from:chars->ast source) keywords)))
; (run (array:concat '("(let x (+ 1 2))" "(let add (lambda a b (+ a (+ b x))))" "(if 0 1 (add x 23))")))

(run (array:concat '("(let add (lambda a b (+ a b)))" "(apply add 10 23)")))