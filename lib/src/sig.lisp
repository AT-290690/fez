(let math:reverse (lambda Number[] (do Number[])))
(let math:map (lambda Number[] (lambda Number (do Number)) (do Number[])))
(let math:select (lambda Number[] (lambda Number (do Boolean)) (do Number[])))
(let math:exclude (lambda Number[] (lambda Number (do Boolean)) (do Number[])))
(let math:fold (lambda Number[] (lambda Number Number (do Number)) Number (do Number)))
(let math:enumerated-fold (lambda Number[] (lambda Number Number Number (do Number)) Number (do Number)))
(let math:every? (lambda Number[] (lambda Number (do Boolean)) (do Boolean)))
(let math:some? (lambda Number[] (lambda Number (do Boolean)) (do Boolean)))
(let math:enumerated-every? (lambda Number[] (lambda Number Number (do Boolean)) (do Boolean)))
(let math:enumerated-some? (lambda Number[] (lambda Number Number (do Boolean)) (do Boolean)))
(let math:enumerated-select (lambda Number[] (lambda Number Number (do Boolean)) (do Number[])))
(let math:enumerated-exclude (lambda Number[] (lambda Number Number (do Boolean)) (do Number[])))
(let math:log-taylor-series (lambda Number Number (do Number)))

(let math:maximum-index (lambda Number[] (do Number)))
(let math:minimum-index (lambda Number[] (do Number)))
(let math:var-def (lambda Number (do Number[])))
(let math:var-get (lambda Number[] (do Number)))
(let math:var-set! (lambda Number[] Number (do Number[])))
(let math:var-del! (lambda Number[] (do Number[])))
(let math:var-set-and-get! (lambda Number[] Number (do Number)))
(let math:var-increment! (lambda Number[] (do Number[])))
(let math:var-decrement! (lambda Number[] (do Number[])))
(let math:var-increment-and-get! (lambda Number[] (do Number)))
(let math:var-decrement-and-get! (lambda Number[] (do Number)))
(let math:var-add! (lambda Number[] Number (do Number)))
(let math:var-subtract! (lambda Number[] Number (do Number)))
(let math:var-multiply! (lambda Number[] Number (do Number)))
(let math:var-divide! (lambda Number[] Number (do Number)))
(let math:var-add-and-get! (lambda Number[] Number (do Number)))
(let math:var-subtract-and-get! (lambda Number[] Number (do Number)))
(let math:var-multiply-and-get! (lambda Number[] Number (do Number)))
(let math:var-divide-and-get! (lambda Number[] (do Number)))
(let math:max-sub-array-sum (lambda Number[] (do Number)))
(let math:median (lambda Number[] (do Number)))
(let math:mean (lambda Number[] (do Number)))
(let math:subset (lambda Unknown[] (do Unknown[][])))
(let math:permutations (lambda Unknown[] (do Unknown[][])))
(let math:combinations (lambda Unknown[] (do Unknown[][])))
(let math:combinations-n (lambda Unknown[] Number (do Unknown[][])))
(let math:variants (lambda Unknown[] Number (do Unknown[][])))
(let math:unique (lambda Number[] (do Number[])))
(let math:divisors (lambda Number (do Number[])))
(let math:remove-leading-zeroes (lambda Number[] (do Number[])))
(let math:sort (lambda Number[] (lambda Number Number (do Boolean)) (do Number[])))

(let var:def (lambda Any (do Unknown[])))
(let var:get (lambda Unknown[] (do Any)))
(let var:set! (lambda Unknown[] Any (do Unknown[])))
(let var:del! (lambda Unknown[] (do Unknown[])))
(let var:set-and-get! (lambda Unknown[] Any (do Any)))

(let array:first (lambda Unknown[] (do Any)))
(let array:second (lambda Unknown[] (do Any)))
(let array:third (lambda Unknown[] (do Any)))
(let array:last (lambda Unknown[] (do Any)))
(let array:get (lambda Unknown[] Number (do Any)))
(let array:get-number (lambda Number[] Number (do Number)))
(let array:get-array (lambda Unknown[][] Number (do Unknown[])))
(let array:get-boolean (lambda Boolean[] Number (do Boolean)))

(let array:transform (lambda Unknown[] (lambda Unknown[] Unknown (do Unknown)) Unknown[] (do Unknown[])))
(let array:reduce (lambda Unknown[] (lambda Number Unknown (do Number)) Number (do Number)))
(let array:enumerated-reduce (lambda Unknown[] (lambda Number Unknown Number (do Number)) Number (do Number)))
(let array:zip (lambda Unknown[] Unknown[] (do Unknown[][])))
(let array:push! (lambda Unknown[] Any (do Unknown)))
(let array:append! (lambda Unknown[] Any (do Unknown[])))

(let bools:fold (lambda Boolean[] (lambda Boolean Boolean (do Boolean)) Boolean (do Boolean)))
(let boole:def-strict (lambda Boolean (do Boolean[])))
(let boole:get (lambda Boolean[] (do Boolean)))
(let boole:set! (lambda Boolean[] Boolean (do Boolean[])))
(let boole:toggle! (lambda Boolean[] (do Boolean[])))
(let boole:true! (lambda Boolean[] (do Boolean[])))
(let boole:false! (lambda Boolean[] (do Boolean[])))
(let boole:true? (lambda Boolean[] (do Boolean)))
(let boole:false? (lambda Boolean[] (do Boolean)))

(let from:string->array (lambda Number[] Number (do Unknown[][])))
(let from:array->string (lambda Unknown[][] Number (do Number[])))
(let from:strings->integers (lambda Unknown[][] (do Number[])))
(let from:string->integer (lambda Number[] (do Number)))
(let from:integer->string (lambda Number (do Number[])))
(let from:strings->floats (lambda Unknown[][] (do Number[])))
(let from:string->float (lambda Number[] (do Number)))
(let from:float->string (lambda Number (do Number[])))
(let from:chars->digits (lambda Number[] (do Number[])))
(let from:digits->chars (lambda Number[] (do Number[])))
(let from:digits->integer (lambda Number[] (do Number)))
(let from:integer->digits (lambda Number (do Number[])))